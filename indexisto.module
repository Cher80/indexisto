<?php
/**
 * @file
 * Интеграция с поисковым сервисом Indexisto.
 *
 * http://indexisto.com/
 */
define('INDEXISTO_DEFAULT_STYLES', 'outline-color: transparent;outline: none;background: #FFF url(http://servant.indexisto.com/files/searchbox/search_icon_21px.png) no-repeat scroll 6px center;border: 2px solid rgb(255, 151, 18);border-radius: 5px;width: 202px;padding: 0 0 0 31px;height: 32px;line-height: 23px;color: #abaaaa;font-family: Arial;font-size: 18px;');
define('INDEXISTO_INDEX_DOMAIN_NAME', 'http://' . $_SERVER['SERVER_NAME']);
/**
 * Используем hook_menu().
 *
 * Создаем страницу с настройками поиска.
 */
function indexisto_menu() {
  $is_first_time = variable_get('indexisto_first_time', TRUE);

  // Если первый раз, то мы отображаем другую форму.
  $settings = $is_first_time ? 'indexisto_settings_first_time' : 'indexisto_settings_form';

  $items['admin/config/search/indexisto'] = array(
    'title' => 'Indexisto search',
    'description' => 'Indexisto search settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array($settings),
    'access arguments' => array('administer site configuration'),
    'file' => 'indexisto.admin.inc',
  );


  $items['admin/config/search/indexisto/settings'] = array(
    'title' => 'Indexisto search settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array($settings),
    'access arguments' => array('administer site configuration'),
    'file' => 'indexisto.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  // Мы не показываем настройки пока пользователь не пройдет первые шаги.
  if (!$is_first_time) {
    $items['admin/config/search/indexisto/content_settings'] = array(
      'title' => 'Content settings',
      'description' => 'Позволяет тонко настроить отдачу материалов в индекс.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('indexisto_content_settings'),
      'access arguments' => array('administer site configuration'),
      'file' => 'indexisto.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 1,
    );

    $items['admin/config/search/indexisto/batch'] = array(
      'title' => 'Bulk operations',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('indexisto_batch_form'),
      'access arguments' => array('administer site settings'),
      'file' => 'indexisto.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 2,
    );
  }

  return $items;
}

/**
 * Используем hook_block_info().
 *
 * Объявляем наш блок с полем поиска.
 */
function indexisto_block_info() {
  $blocks = array();

  // Если не указан ID поискового индекса, мы не генерируем блок.
  if (variable_get('indexisto_index_id', FALSE)) {
    $blocks['indexisto_search'] = array(
      'info' => t('Indexisto search'),
    );
  }

  return $blocks;
}

/**
 * Используем hook_block_view().
 *
 * Мы перехватываем обработку вывода блока и пишем в него нужный код.
 */
function indexisto_block_view($delta) {
  $block = array();

  // Ловим наш блок.
  if ($delta == 'indexisto_search') {
    $index_id = variable_get('indexisto_index_id');
    // Автозаполнение.
    variable_get('indexisto_autocomplete', FALSE) ? $autocomplete = 'on' : $autocomplete = 'off';
    // Автокоррекция.
    variable_get('indexisto_autocorrect', FALSE) ? $autocorrect = 'on' : $autocorrect = 'off';
    $placeholder = variable_get('indexisto_placeholder', 'Начните ввод');
    // Стили ипута.
    $styles = variable_get('indexisto_input_style', INDEXISTO_DEFAULT_STYLES);

    $block['content'] = "<input autocomplete='{$autocomplete}'  autocorrect='{$autocorrect}' id='indx_srchbox_{$index_id}' placeholder='{$placeholder}' style='{$styles}' type='text' />";
  }

  return $block;
}

/**
 * Используем hook_preprocess_html().
 *
 * При подготовке страницы мы цепляем JS файл.
 */
function indexisto_preprocess_html(&$variables) {
  drupal_add_js('http://servant.indexisto.com/files/searchbox/searchbox.nocache.js?type=edit', 'external');
}

/**
 * Используем hook_node_insert().
 *
 * Перехватываем в момент добавления в базу.
 */
function indexisto_node_insert($node) {
  if ($node->status) {
    $data = indexisto_node_data_prepare($node);
    indexisto_send_data($data);
  }
}

/**
 * Используем hook_node_update().
 *
 * Перехватываем в момент обновления содержимого.
 */
function indexisto_node_update($node) {
  if ($node->status) {
    $data = indexisto_node_data_prepare($node);
    indexisto_send_data($data);
  }
}

/**
 * Используем hook_node_delete().
 *
 * Перехватываем в момент удаления содержимого.
 */
function indexisto_node_delete($node) {
  // Записываем id удаляемого содержимого.
  $values = array(
    '_id' => $node->nid,
  );

  // Обрабатываем данные.
  $data = json_encode($values);

  // Посылаем запрос что удалили.
  indexisto_send_data($data, 'DELETE');
}

/**
 * @param $node
 * @param $operation
 *
 * Подготовка данных для отсылки в api для нод.
 */
function indexisto_node_data_prepare($node) {
  // Если только это необходимо и не запрещено для текущей ноды.
  if (variable_get('indexisto_send_data', 0) && !variable_get('indexisto_' . $node->type . '_send_data', 0)) {
    // Передаем базовые настройки.
    $values = array(
      '_id' => $node->nid,
      'created' => $node->created,
      '_subtype' => $node->type,
      '_url' =>  INDEXISTO_INDEX_DOMAIN_NAME . 'node/' . $node->nid,
    );

    // Количество комментариев.
    isset($node->comment_count) ? $values['comments'] = $node->comment_count : FALSE;

    // Подготовка URL материала.
    // Перезаписываем системный URL.
    if (variable_get('indexisto_path_aliases', 1)) {
      if (!empty($node->path['alias'])) {
        $values['_url'] = INDEXISTO_INDEX_DOMAIN_NAME . $node->path['alias'];
      }
      else {
        $alias = url('node/' . $node->nid);
        $values['_url'] = INDEXISTO_INDEX_DOMAIN_NAME . $alias;
      }
    }

    // Если задан заголовок.
    $title = variable_get('indexisto_' . $node->type . '_title', FALSE);
    $title ? $values['title'] = token_replace($title, array('node' => $node)) : FALSE;

    // Если задано содержимое.
    $body = variable_get('indexisto_' . $node->type . '_body', FALSE);
    $body ? $values['body'] = token_replace($body, array('node' => $node), array('clear' => TRUE)) : FALSE;

    // Если задано изображение.
    $image = variable_get('indexisto_' . $node->type . '_image', FALSE);
    // К сожалению, токен с изображением обрабатывается не правильно, поэтому
    // мы берем инициативу на себя. Мы из токена получаем название поля которое
    // пользователь указал в качестве картинки, и тянем его значение на прямую
    // из нашего содержимого.
    if ($image) {
      preg_match_all('/\[([^\s\[\]:]*)([^\s\[\]]*)\]/x', $image, $matches);
      // Убираем двоеточие и получаем название поля с изображением.
      $image_field_name = str_replace(":", "", $matches[2][0]);
      // Переводим нижние слеши в тире, ведь есть два вида токенов.
      $image_field_name = str_replace("-", "_", $image_field_name);

      // Если указанное поле существует.
      if (!empty($node->{$image_field_name}['und'][0]['fid'])) {
        // Получаем ID первого изображения.
        $image_fid = $node->{$image_field_name}['und'][0]['fid'];
        // Грузим файл.
        $image_loaded = file_load($image_fid);
        // Получаем URL.
        $values['_image'] = file_create_url($image_loaded->uri);
      }
      // Если нет картинки то пробуем найти первую в теле документа.
      elseif (!empty($values['body'])) {
        preg_match('/<img.+src=[\'"](?P<src>.+?)[\'"].*>/i', $values['body'], $image);
        // Если есть домен в ссылке картинки, то тупо записываем.
        if ($image && preg_match('/^(http|https):\\/\\/([A-Z0-9][A-Z0-9_-]*(?:.[A-Z0-9][A-Z0-9_-]*)+):?(d+)?\\/?/i', $image['src'])) {
          $values['_image'] = $image['src'];
        }
        // Ну а иначе добавляем.
        elseif ($image) {
          $values['_image'] = 'http://' . $_SERVER['SERVER_NAME'] . $image['src'];
        }
      }
    }
    elseif (!empty($values['body'])) {
      preg_match('/<img.+src=[\'"](?P<src>.+?)[\'"].*>/i', $values['body'], $image);
      // Если есть домен в ссылке картинки, то тупо записываем.
      if ($image && preg_match('/^(http|https):\\/\\/([A-Z0-9][A-Z0-9_-]*(?:.[A-Z0-9][A-Z0-9_-]*)+):?(d+)?\\/?/i', $image['src'])) {
        $values['_image'] = $image['src'];
      }
      // Ну а иначе добавляем.
      elseif ($image) {
        $values['_image'] = 'http://' . $_SERVER['SERVER_NAME'] . $image['src'];
      }
    }

    // Если заданы теги.
    $tags = variable_get('indexisto_' . $node->type . '_tags', FALSE);
    $tags ? $values['tags'] = token_replace($tags, array('node' => $node), array('clear' => TRUE)) : FALSE;

    // Sumtext
    $sumtext = variable_get('indexisto_' . $node->type . '_sumtext', '[node:body]');
    $sumtext ? $values['_sumtext'] = token_replace($sumtext, array('node' => $node), array('clear' => TRUE)) : FALSE;

    // Финальная подготовка данных, а также удаления переносов и табуляции.
    $data = str_replace(array("\\n", "\\t", "\\r"), "", strip_tags(json_encode($values)));

    // Создаем собственный хук hook_indexisto_node_data_prepare_alter().
    // Мы не будем ничего делать если его никто не использует.
    if (sizeof(module_implements('indexisto_node_data_prepare_alter')) > 0) {
      // Если его вызывали то отдаем данные.
      $alter_data = module_invoke_all('indexisto_node_data_prepare_alter', $data);
      drupal_alter('indexisto_node_data_prepare_alter', $data);
      // Берем измененные данные из массива.
      $data = $alter_data[0];
    }

    // Возвращаем данные.
    return $data;
  }
}

/**
 * Используем hook_comment_insert().
 *
 * Перехватываем в момент добавления в базу.
 */
function indexisto_comment_insert($comment) {
  if ($comment->status) {
    $data = indexisto_comment_data_prepare($comment);
    indexisto_send_data($data);
  }
}

/**
 * Используем hook_comment_update().
 *
 * Перехватываем в момент обновления.
 */
function indexisto_comment_update($comment) {
  if ($comment->status) {
    $data = indexisto_comment_data_prepare($comment);
    indexisto_send_data($data);
  }
}

/**
 * Используем hook_comment_delete().
 *
 * Перехватываем в момент удаления.
 */
function indexisto_comment_delete($comment) {
  // Записываем id удаляемого комментария.
  $values = array(
    '_id' => $comment->cid,
  );

  // Обрабатываем данные.
  $data = json_encode($values);

  // Посылаем запрос что удалили.
  indexisto_send_data($data, 'DELETE');
}

/**
 * @param $comment
 *
 * Подготовка данных для отсылки в api для комментариев.
 */
function indexisto_comment_data_prepare($comment) {
  // Если индексация комментариев разрешена (0).
  if (!variable_get('indexisto_comments_send_data', 0)) {
    $values = array(
      '_id' => $comment->cid,
      'created' => $comment->created,
      '_subtype' => 'comments',
    );

    // Загружаем ноду к которой комментарий.
    $node = node_load($comment->nid);

    // Путь алиас или системный.
    $alias = url('node/' . $node->nid);
    $values['_url'] = INDEXISTO_INDEX_DOMAIN_NAME . $alias . '#comment-' . $comment->cid;

    // Если задано содержимое.
    $body = variable_get('indexisto_comments_body', '[comment:body]');
    $body ? $values['_sumtext'] = strip_tags(token_replace($body, array('comment' => $comment), array('clear' => TRUE))) : FALSE;

    // Финальная подготовка данных, а также удаления переносов и табуляции.
    $data = str_replace(array("\\n", "\\t", "\\r"), "", strip_tags(json_encode($values)));

    // Создаем собственный хук hook_indexisto_comment_data_prepare_alter().
    // Мы не будем ничего делать если его никто не использует.
    if (sizeof(module_implements('indexisto_comment_data_prepare_alter')) > 0) {
      // Если его вызывали то отдаем данные.
      $alter_data = module_invoke_all('indexisto_comment_data_prepare_alter', $data);
      drupal_alter('indexisto_comment_data_prepare_alter', $data);
      // Берем измененные данные из массива.
      $data = $alter_data[0];
    }

    return $data;
  }
}

/**
 * @param $data
 * @param $method
 *
 * Отправка данных в базу.
 */
function indexisto_send_data($data, $method = 'POST') {
  $api_url = 'http://api.indexisto.com';
  $api_version = '/1.0';
  $document = '/document';
  $indexid = '/' . variable_get('indexisto_index_id');
  $secret = variable_get('indexisto_secret_api_key');

  // Создаем URL для отсылки данных.
  $request_url = $api_url . $api_version . $document . $indexid . '/default';

  // Создаем URL для подписи данныех.
  $sign_url = $api_version . $document . $indexid . '/default';

  // Генерируем ключ для отсылки данных.
  $code = md5($sign_url . $data . $secret);

  $options = array(
    'method' => $method,
    'data' => $data,
  );

  // Выполняем запрос.
  $result = drupal_http_request($request_url . '?code=' . $code, $options);
}


/**
 * @param $form
 * @param $form_state
 *
 * Старт батча.
 */
function indexisto_batch_start($form, &$form_state) {
  // Тип выбранной операции.
  // 0 - обновление и\или добавление в индекс.
  // 1 - удаление из индекса.
  $operation_type_id = $form_state['values']['batch_operation_type'];
  $operation_type_name = $operation_type_id ? 'DELETE' : 'POST';

  // Информация об операциях.
  $operations = array(
    0 => array(
      'name' => 'Добавление и\или обновление индекса',
      'function' => '_batch_indexisto_do',
    ),
    1 => array(
      'name' => 'Удаление из индекса',
      'function' => '_batch_indexisto_do',
    ),
  );

  // Над какими типами содержимого выполняем.
  $operation_content_types = array();

  // Добавляем в масив выбранные типы содержимого.
  foreach ($form_state['values']['batch_operation_content_types'] as $type_name => $status) {
    if ($status) {
      $operation_content_types[] = $type_name;
    }
  }

  // Подготовка батча
  $batch = array(
    'title' => $operations[$operation_type_id]['name'],
    'operations' => array(
      array($operations[$operation_type_id]['function'], array($operation_content_types, $operation_type_name)),
    ),
    'progress_message' => 'Статус операции: @current из @total.',
    'error_message' => t('Error!'),
    'finished' => 'indexisto_batch_finished',
  );

  batch_set($batch);
}

/**
 * Добавляем данные в индекс.
 */
function _batch_indexisto_do($content_types, $operation_type, &$context) {
  // Если это комментарии, то обработка иная.
  $is_comment = in_array('comment', $content_types) ? TRUE : FALSE;

  // Для каждого указанного типа.
  // Получем все id нод нужного нам типа.
  if ($is_comment) {
    $cids = db_select('comment', 'c')
      ->fields('c', array('cid'))
      ->condition('c.status', 1)
      ->execute()
      ->fetchCol();
  }
  else {
    // Список всех id нод.
    $nids = array();

    foreach ($content_types as $content_type) {
      $nids_new = db_select('node', 'n')
        ->fields('n', array('nid'))
        ->fields('n', array('type'))
        ->condition('n.type', $content_type)
        ->execute()
        ->fetchCol();

      $nids = array_merge($nids, $nids_new);
    }
  }

  // Получаем количество данных.
  if (empty($context['sandbox']['progress'])) {
    // Текущее состояние.
    $context['sandbox']['progress'] = 0;
    // Всего.
    if ($is_comment) {
      $context['sandbox']['max'] = count($cids);
    }
    else {
      $context['sandbox']['max'] = count($nids);
    }

    // Добавляем операцию в бд.
    watchdog('import', 'import indexisto');
  }

  // Текущая итерация.
  if (empty($context['sandbox']['iteration'])) {
    $context['sandbox']['iteration'] = 0;
  }

  // Проверяем не закончился ли цикл.
  if ($context['sandbox']['iteration'] < $context['sandbox']['max']) {
    // Указываем сколько за один цикл проделывать операций, чтобы не
    // положить сервер от нагрузки.
    $limit = 10;

    // Количество уже проделанных операций.
    $counter = 0;

    if ($context['sandbox']['progress'] != 0) {
      $context['sandbox']['iteration'] = $context['sandbox']['iteration'] + $limit;
    }

    // Прогоняем наши данные.
    for ($i = $context['sandbox']['iteration']; $i < $context['sandbox']['max'] && $counter < $limit; $i++) {
      if ($is_comment) {
        $comment = comment_load($cids[$i]);
        $data = indexisto_comment_data_prepare($comment);
        indexisto_send_data($data, $operation_type);
      }
      else {
        // Грузим ноду и отсылаем.
        $node = node_load($nids[$i]);
        $data = indexisto_node_data_prepare($node);
        indexisto_send_data($data, $operation_type);
      }

      // Указываем батчу что мы выполнили один продукт.
      $context['sandbox']['progress']++;
      $counter++;

      // Выводим инфу для юзера.
      $context['message'] = 'Выполнение операций.';
      $context['results']['processed'] = $context['sandbox']['progress'];
    }
  }

  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * @param $success
 * @param $results
 * @param $operations
 *
 * Сообщение результатов по окончанию.
 */
function indexisto_batch_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message('Выполнено');
  }
  else {
    $error_operation = reset($operations);
    drupal_set_message(t('An error occurred while processing @operation with arguments : @args', array(
      '@operation' => $error_operation[0],
      '@args' => print_r($error_operation[0], TRUE)
    )));
  }
  watchdog('import', 'import finished');
}
